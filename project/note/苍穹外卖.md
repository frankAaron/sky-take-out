# day01

### 导入资料

遇见报错：Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.10.1:compile

问题原因：JDK与maven不匹配

解决：重新安装JDK7，环境配置，IDEA中配置JDK版本  我的是21，其他方法也行，我是小白所以多次尝试选择安装17

遇见问题：yapi pro太慢，太卡

解决：使用apifox，我学的javaweb用的是postman

遇见问题：导入不成功，正常导入看一看（[苍穹外卖使用Apifox代替Swagger进行接口测试(详细图解)_apifox 自动化测试 添加测试数据到接口参数中 ${params}-CSDN博客](https://blog.csdn.net/2301_80558092/article/details/149151038)）我的apifox选择yapi导入只有一个接口

解决：deepseek将yapi json文件转成open api

我自己转的，可以自己转

链接:https://pan.baidu.com/s/1rTFNtAaeHgZp2TBGYV9JiA?pwd=5xbx 提取码:5xbx 复制这段内容后打开百度网盘手机App，操作更方便哦

选择这个

![](img/%E5%AF%BC%E5%85%A5%E4%BD%8D%E7%BD%AE.png)

#### 知识点

nginx反向代理好处：

-   调高访问速度
-   **负载均衡**：把大量的请求按照我们指定的方式**均衡**的分配给集群中的每台服务器
-   保证后端服务安全，前端不能直接访问，只能通过nginx

nginx.conf配置反向代理

        # 反向代理,处理管理端发送的请求
        location /api/ {
    		proxy_pass   http://localhost:8080/admin/;
            #proxy_pass   http://webservers/admin/;
        }

![](img/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png)

负载均衡

	upstream webservers{
	  server 127.0.0.1:8080 weight=90 ;
	  #server 127.0.0.1:8088 weight=10 ;
	}

负载均衡策略

| 名称       | 说明                                                 |
| ---------- | ---------------------------------------------------- |
| 轮询       | 默认方式                                             |
| weight     | 权重方式，默认为1，权重越高，被分配的客户端请求越多  |
| ip_hash    | 依据IP分配方式，每个方可固定访问一个客户端           |
| least_conn | 依据最少连接方式，把请求优先分配给连接数少的后端服务 |
| url_hash   | 依据url分配，相同的url分配到同一个后端服务           |
| fair       | 依据响应时间方式，响应时间短的服务将会被优先分配     |

md5加密处理

e10adc3949ba59abbe56e057f20f883e=123456

```
DigestUtils.md5DigestAsHex(password.getBytes())
```

接口文档   到yapi

swagger  测试后端代码（参数比较多的情况）

| 注解              | 说明                                     |
| ----------------- | ---------------------------------------- |
| @Api              | 用在类上，例如Controller，表示对类的说明 |
| @ApiModel         | 用在类上                                 |
| @ApiModelProperty | 用在属性上，描述属性信息                 |
| @ApiOperation     | 用在方法上，说明方法用途，作用           |

# day02

## 新增员工

报错：前端报错500，

问题：debug排查，mapping层sql语句错误，注意：json数据------手机号11位，身份证18位

报错：SQLIntegrityConstraintViolationException，添加重复没有处理----前端也会报错500

解决：Handel解决，后续有解决方法

### 知识点

```
//对象属性拷贝（两个类是相同属性，属性名称一致）
BeanUtils.copyProperties(src,dest);
```

#### ThreadLocal

不是线程，是线程的局部变量

ThreadLocal为每个线程提供**单独的存储空间**，具有**线性隔离效果**，只有在线程内才能获取对应的值，**线程外不能访问**,使得**每个线程可以独立地持有自己的变量副本**，而不是[共享变量](https://so.csdn.net/so/search?q=共享变量&spm=1001.2101.3001.7020)

**常用方法：**

-   public void set(T value) 设置当前线程的线程局部变量的值
-   public T get() 返回当前线程所对应的线程局部变量的值
-   public void remove() 移除当前线程的线程局部变量



## 员工分页查询

### 知识点

1.  query传参：以?key=value的形式呈现

2.  分页查询：插件----pagehelper，pom.xml导入依赖 ，返回值是page对象，自动拼接limit

3.  时间在前端显示为数组，换成正常时间   ----> 在属性上@JsonFormat(pattern ="yyyy-MM-dd HH:mm:ss")  

    或者重写Spring框架里自带的一个方法extendHandlerExceptionResolvers，扩展消息转换器

    ```java
    /**
     * 扩展Spring MVC框架的消息转换器
     * @param exceptionResolvers
     */
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters){
        log.info("扩展消息转换器...");
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，将java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转换器converter加入容器converters里,并优先使用
        converters.add(0, converter);
    }
    ```

<select id="pageQuery" resultType="com.sky.entity.Employee"> 
    select * from  employee        
    <where>            
        <if test="name != null and name !=’‘">                
            and name like concat('%',#{name},'%')   //模糊搜索+字符串拼接               
        </if>       
    </where>        
    order by create_time desc   //降序排序   
</select>   

没搞懂为什么要加and   ------>MyBatis的 `<where>` 标签会自动处理以下情况：

-   **去除开头多余的AND/OR**：如果标签内的内容以AND或OR开头，会自动去除
-   **动态生成WHERE**：只有当标签内有内容时，才会生成WHERE关键字

不加and就会出现

```sql
WHERE name like concat('%',?,'%') status = ?  -- 语法错误，缺少AND
```

## 启用禁用员工账号

很常规的Controller层，service层，mapper层

个人认为如果只是完成禁用启用员工账号完全没有必要写这么多，写这么多代码完全可以实现万能更新

    <update id="update">
        update employee
        <set>
            <if test="name != null">name = #{name},</if>
            <if test="username != null">username = #{username},</if>
            <if test="password != null">password = #{password},</if>
            <if test="phone != null">phone = #{phone},</if>
            <if test="sex != null">sex = #{sex},</if>
            <if test="idNumber != null">id_Number = #{idNumber},</if>
            <if test="updateTime != null">update_Time = #{updateTime},</if>
            <if test="updateUser != null">update_User = #{updateUser},</if>
            <if test="status != null">status = #{status},</if>
        </set>
        where id = #{id}
    </update>

单纯完成此业务逻辑可以：

```sql
<update id="updateStatusWithAudit">
    update employee set 
        status = #{status},
        update_user = #{updateUser},
        update_time = #{updateTime}
    where id = #{id}
</update>
```

当然简单点

```sql
<update id="updateStatus">
    update employee set status = #{status} where id = #{id}
</update>
```

## 编辑员工

```
employee.setPassword("******");
```

防止前端从开发者模式中看到密码

同时这里验证了启用禁用员工账号部分那里是为了实现万能更新减少代码冗余

## 导入功能代码

报错：org.apache.maven.plugins:maven-compiler-plugin:3.10.1:compile

解决：

```shell
# 清理并重新编译
mvn clean compile

# 如果仍有问题，强制更新依赖
mvn clean compile -U

# 跳过测试
mvn clean compile -DskipTests
```

# day03

这篇文章主要是小白我遇见的问题以及解决方法，没有源码（源码跟着视频敲就行），希望对你有所帮助。

## 公共字段

### 知识点

#### 枚举

Java 枚举（enum）是一个特殊的类，一般表示一组常量，枚举类使用 enum 关键字来定义，各个常量使用逗号 **,** 来分割。

内部类，switch中均可以使用枚举

-   values() 返回枚举类中所有的值。
-   ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。
-   valueOf()方法返回指定字符串值的枚举常量。

### aop

| 常用概念名称          | 说明                                   |
| --------------------- | -------------------------------------- |
| 连接点 （Jointpoint） | 被拦截到的点，可以被动态代理拦截目标类 |
| 切入点（Pointcut）    | 被拦截的**连接点**                     |
| 通知（Advice）        | 拦截后需要做的事情                     |
| 目标（Target）        | 代理的目标对象                         |
| 植入（Waving）        | 生成代理对象的过程                     |
| 代理（Proxy）         | 生成代理对象                           |
| 切面（Aspect）        | 切入点+通知                            |

工作流程

spring容器启动--->读取是所有切面配置中的切入点---->初始化bean，判断对应的类中是否匹配---->创建原始对象的代理对象---->获取bean

![](img/%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)

### 自定义注解

```java
@Target(ElementType.METHOD )//注解出现的位置
```

```
@Retention(RetentionPolicy.RUNTIME)
```

@Retention作用是定义**被它所注解的注解保留多久**，一共有三种策略，定义在RetentionPolicy枚举中.

-   source：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；被编译器忽略
-   class：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期
-   runtime：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在